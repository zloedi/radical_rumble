









   RADICAL MULTIPLAYER       prostranstvoto_guest : prostranstvoto789









    Who am I














    Why the Radical
        * De-indoctrinate, alternative approach to code games.
        * Meet other programmers and talk about real programming. (group therapy?)
        * Learn new stuff.
        * To create ?useful? software.
        * To promote prostranstvoto.bg (there is a donation pot, please donate)
        * Drink alcohol.
        * Source code
            https://github.com/zloedi/radical_rumble
            https://github.com/zloedi/ZloediUtils
            The missing 'Content' HOWTO -- on the Discord.
    
    
    
    
    





    Revisit SDL/Unity, Structs of Arrays, clocks and more
        * Compile as Unity assembly, SDL exe and headless standalone server.
        * SOA of primitive types exclusively on game state (class Game):
            Pawn, Board, Player
        * Filters
        * Same mechanism to serialize deltas everywhere (network, map editor, /savegames/)
        * Use future timestamps to sync lerps, don't send packets inbetween. Server clock always
            piggybacked.
        * Single tick/monobehaviour (the local server runs in the same tick too)
        * Use unreliable UDP stack ('inspired by' Quake3)
            Each tick potentially generates delta.
            64 deltas per client in a circular buffer.
            Resend deltas from last ack to current.
            Currently deltas are string, too lazy to make them compressed bytes.
        * Extensive Qonsole/Cellophane usage (thank you C# reflection):
            Use the Cellophane for client commands, server can push 'tail' commands in packets.
            Map keys to Cellophane commands, store in the Cellophane cfg.
            Cellophane on the standalone.
        * Hex grid for navigation with agent avoidance on top (sorta broken)
        * IMM 3d models and animation. Animo for animations.

    
    
    




    





    What we have have implemented so far (WIP):
        Client/Server (networking)
        Avoidance and pathing
        QGL Client / Unity Client
        Some animated 3d models
        GUI
        Join the Discord for the Content
        













    IMGUI vs Retained GUI
        No instantiation / initialization.
        No event subscription.
        Explicit rendering order and visibility.
        Easier to do 'procedural' or 'dynamic' widgets.
        Reuse by simple calll
        Programmer-centric.









    QUI: input, coord system top-down/left-right, scissoring, procedural widgets or prefabs handling
        One frame lag
        Slow (esp text)
        Hashes play

        Begin(x,y);
            QUI.Call( ..., id -- generated by hashing <line> <file> [explicit handle] )
        End();










    WrapBox: hierarchycal layout/anchoring, virtual coordinates aka 'canvas scaling'.
        Immutable struct.
        System independent (can be used with SDL!).
        WBox handle/id propagated down to children and mutated if handle passed










    WBUI: WrapBox + QUI -- QUI widgets with WrapBox layouting instead of raw coords,
        hashes are generated again from line, file but the wbox id-s are thrown-in too









    Healthbars









    Manabar










    The drag and drop example











    The pot
