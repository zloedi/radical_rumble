









    Who am I














    Why the Radical (launch four clients)
    https://github.com/zloedi/radical_rumble
    https://github.com/zloedi/ZloediUtils
    
    
    
    
    





    SDL/Unity, Structs of Arrays, clocks and more
    
    









    Movement Logic -- data
    
    
    
    
    
    
    
    
    
    
    
    
    // non-synced
    Vector2 [] Pawn.mvPos
    Vector2 [] Pawn.mvEnd
    
    // synced
    int [] Pawn.mvEnd_tx
    int [] Pawn.mvEnd_ms
    
    // client-only
    Vector2 [] Pawn.mvStart
    Vector2 [] Pawn.mvStart_ms
    
    
    
    
    
    
    
    
    
    
    Movemen Logic -- tick
    
    
    
    
    
    
    
    
    
    
    
     
    -= server =-
    
    1. Decide on end point.
    2. Chase the end point; When reached decide again.
        (for actual tick examples -- pawn states are shown later)
    
    
    
    
    
    
    
    



    
    // setting up a new segment
    pawn.mvEnd[z] = chase;
    pawn.mvEnd_ms[z] = serverClock + MvDurationMs( z, pawn.mvPos[z], pawn.mvEnd[z] );










    // tick in general:
    if ( pawn.ChaseEndPoint( z, serverClock ) ) {
        // decide again when segment is done (end point is reached and the timestamp is hit)
    }
    // at the end of server tick, move to 8:8 fixed point to be transferred
    pawn.mvEnd_tx = ToTx( pawn.mvEnd );







    
    
    
    
    
    -= client =-
    
    1. When a new segment arrives, store the current position in mvStart
    2. Each frame lerp mvStart to mvEnd
    
    
    
    
    
    
    
    
    
    
    
    
    // client handling of incoming network events. (generated by net packets inspection)

    if ( TriggerOn( z, Trig.Move ) ) {
        // new movement segment arrives, plan movement on the client
        pawn.mvStart[z] = pawn.mvPos[z];
        pawn.mvStart_ms[z] = clock;
    }
    
    if ( TriggerOn( z, Trig.Spawn ) ) {
        // newly spawned unit, make sure it has proper position
        pawn.mvPos[z] = pawn.mvEnd[z];
    }
    
    
    
    
    
    
    
    
    
    // client tick
    // 
    // ... for all pawn.filter.no_strucutres and pawn.filter.flying ...









    // server clock here
    if ( pawn.mvEnd_ms[z] <= Cl.serverClock ) {
        // if the end timestamp is behind the server clock, stop
        // may end up a bit off the actual position (do we care)
        pawn.mvStart_ms[z] = pawn.mvEnd_ms[z] = clock;
    }









    else if ( pawn.mvEnd_ms[z] <= unityClock  ) {
        // hide the lag at inflection points by keep moving
        // in the same direction until a new segment arrives
    }










    else {
        mvPos[z] = Vector2.Lerp( mvStart[z], mvEnd[z], t );
    }
    
    
    


    


    


    The rest is server only


    
    
    
    
    
    
    
    


   Pathing -- the HexPather (what astar?)
   1. Fill the navmap with blocked tiles.
   2. Flood the scoremap with score according to the navmap.
   3. Trace a path.

   








   -= the pather API =-

   // reuse the context for tracing multiple paths
   Context CreateContext( int navMapSize );

   // before being able to trace paths, you need to flood the map
   // origin and target are indices, not coordinates
   bool FloodMap( int origin, int maxRange, int navMapPitch,
                                                byte [] navMap, int navMapLength, Context ctx );

   // origin is already stored in context by Flood
   bool TracePath( int target, int floodMapPitch, Context ctx, List<int> ioResult );











    Pathing -- data













    byte [] terrain = null
    byte [] navMap = null
    HexPather.Context patherCTX
    List<int> path
    List<int> strippedPath












    Pathing -- getting a path in grid












    -= fill the obstacle map =-

    // passable
    foreach ( var hx in filter.solid ) navMap[hx] = 0;

    // blocked
    foreach ( var hx in filter.no_solid ) navMap[hx] = 1;

    // force passable on origin
    navMap[hxSrc] = 0;









    -= find path =-

    // flood the map with score
    HexPather.FloodMap( hxSrc, maxPath, width, navMap, numItems, patherCTX );

    // put the geometrical distance in the score
    foreach ( var hx in filter.solid ) {
        int dist = SqrDistance( hx, hxSrc );
        patherCTX.floodMap[hx] = ( patherCTX.floodMap[hx] << 16 ) | dist;
    }

    // trace and strip the path
    HexPather.TracePath( hxTarget, width, patherCTX, path );
    StripPath();













    Demo of the Editor F3 -- pather test (draw_skip_big_red_message ; ed_load crazy)













    Pathing -- the cache











    -= the cache data =-

    // the values could be lists of ushorts here
    // the values could be arrays
    // key is end hexes, combined
    Dictionary<int,List<int>> pathCache;












    -= multilevel =-

    if ( ! board.GetPath( hxSrc, hxTarget, maxPath: 5 ) ) {
        if ( ! board.GetPath( hxSrc, hxTarget, maxPath: 10 ) ) {
            board.GetPath( hxSrc, hxTarget );
        }
    }
    CachePathSubpaths( hxSrc, hxTarget, board.strippedPath );










    Demo of sv_show_paths 2 (ed_load crazy)











    Navigation -- the pawn states











    1. Idle
    2. Patrol *
    3. ChargeEnemy *
    4. Attack









    -= patrol =-

    foreach ( var z in pawn.filter.ByState( PS.Patrol ) )








    // 'true' result means end-point-reached here
    if ( pawn.MvLerp( z, serverClock ) ) {
        // path inflection point, get a new segment to lerp on
        if ( ! MvPatrolUpdate( z ) ) {
            // nothing to focus on for navigation
            Log( $"{pawn.DN( z )} no navigation target, go to Idle." );
            pawn.SetState( z, PS.Idle );
        }
    }












    else if ( AtkGetFocusPawn( z, out int zEnemy ) ) {
        pawn.focus[z] = ( byte )zEnemy;
        Log( $"{pawn.DN( z )} charges {pawn.DN( zEnemy )}" );
        pawn.SetState( z, PS.ChargeEnemy );
    }












    -= chase enemy =-

    foreach ( var z in pawn.filter.ByState( PS.ChargeEnemy ) )










    
    // keep polling for enemies
    if ( AtkGetFocusPawn( z, out int ze ) ) {
        pawn.focus[z] = ( byte )ze;
    } else {
        pawn.focus[z] = 0;
        Log( $"{pawn.DN( z )} nothing to charge, go to Patrol." );
        pawn.SetState( z, PS.Patrol );
    }






    if ( pawn.MvLerp( z, serverClock ) ) {
        // this will notify the client by sending a fresh clock
        // it will make the pawn stop
        pawn.MvSnapToEnd( z, ZServer.clock );

        // reached attack position, transition to attack
        Log( $"{pawn.DN( z )} starts attacking {pawn.DN( pawn.focus[z] )}" );
        pawn.SetState( z, PS.Attack );
    } else {
        // chase enemy, updating end position, frequency depending on distance
        MvChase( z, pawn.focus[z] );
    }












    Demo of adaptive chase (ed_load chase ; cl_spawn_directly ; sv_show_charge 1)











    Navigation -- avoidance (wip)








    



    RR's Steering Behaviour (sorta) overview
        * Separate (colinear) and avoid (orthogonal)
        * Put a sphere (in the future) of the pawn.
        * Try to keep the spheres separated.






    


    Steering spheres
        1. velocity -- the 'feeler' ahead of time describing velocity direction
        2. detour -- when clipping with attacking teammate, place it around the attack target
            temporary, clips with single other sphere













    Single solver for all spheres -- split constraint (distance constraints pic).
        mobile pawns have inverted mass 0, inert -- 1












    Demo avoidance (draw_skip_pawns 1 ; sv_show_radiuses 1 // sv_show_splits 1 );









