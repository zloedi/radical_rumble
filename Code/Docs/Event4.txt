









   RADICAL MULTIPLAYER       prostranstvoto_guest : prostranstvoto789









    Who am I














    Why the Radical
        * De-indoctrinate, alternative approach to code games.
        * Meet other programmers and talk about real programming. (group therapy?)
        * Learn new stuff.
        * To create ?useful? software.
        * To promote prostranstvoto.bg (there is a donation pot, please donate)
        * Drink alcohol.
        * Source code
            https://github.com/zloedi/radical_rumble
            https://github.com/zloedi/ZloediUtils
    
    
    
    
    





    Revisit SDL/Unity, Structs of Arrays, clocks and more
        * Compile as Unity assembly, SDL exe and headless standalone server.
        * SOA of primitive types exclusively on game state (class Game):
            Pawn, Board, Player
        * Filters
        * Same mechanism to serialize deltas everywhere (network, map editor, /savegames/)
        * Use future timestamps to sync lerps, don't send packets inbetween. Server clock always
            piggybacked.
        * Single tick/monobehaviour (the local server runs in the same tick too)
        * Use unreliable UDP stack ('inspired by' Quake3)
            Each tick potentially generates delta.
            64 deltas per client in a circular buffer.
            Resend deltas from last ack to current.
            Currently deltas are string, too lazy to make them compressed bytes.
        * Extensive Qonsole/Cellophane usage (thank you C# reflection):
            Use the Cellophane for client commands, server can push 'tail' commands in packets.
            Map keys to Cellophane commands, store in the Cellophane cfg.
            Cellophane on the standalone.
    
    
    




    








    Being client/server means you can always jump in and out of a game. Killing the client, is of no consequence.
    






    Retained mode / event driven visuals
        Create
        Update
        Handle events
        Cleanup


    Hard while Retained:
        Dependencies
        Order of execution
        Arbitrary change of the 'abstract' (server) game state
        Server enforced clocks


    Immediate mode visuals
        Update -- each frame 'redraw' the game state supplied by the server using the server clock.
        Still convenient to have some event-like mechanism:
            * Triggers
                Flags that live for entire frame, can be handled at multiple places in the tick.
            * SingleShot
                Capture state, pass lambda, tick at the end of the frame.
                Conditional, timeout, delay, done()
                Projectiles implemented as both SingleShot and IMGO

* IMGO
    Controls visibility and hierarchy order by invoke/no-invoke, order of invoke
    Gives reference to game object.
    Gives references to designated children.
    Having imm game objects (polling) means no complicated management,
        just constantly 'draw' the game state.

    Setup a situation on the server, keep it running while developing the client
    Everything is the same on reconnect, no fuss

    Destroying all the IMGOs is ok.
    IMGO vs SingleShot for projectiles.


* Programming animations
    What we need:
        Custom clock to sample.
        Crossfade to any state at any time with custom transition times.
        Arbitrary scale for animation times (and animation transitions)
            attack loop may be shorter than the animation clip
            time to attack may vary each loop.
        Changing the attack/move steps on the server shouldn't require animation mod/reimport.
        Polling, not interested in events.

    What we want -- control of animations down to the individual frame.
    Problems with Animator state machines -- tangled, not enough control.
    Heard about animancer, I wanted something simpler and better fitted for imgo-s.

    Animo
        Put all clips into two Animator layers.

        At runtime, update animation times each tick and use two 'channels' in a circular buffer
            for crossfades.

        'One Shot' animations can be polled for end of animation and crossfade back to a loop.
            in our case either 'move' or 'idle', not much idling there though

        Sample animations each tick by using Animator.SetLayerWeight() and Animator.Play()
        Some performance loss.

